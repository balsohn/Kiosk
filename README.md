# 🍔 쉐이크쉑 키오스크 프로젝트

## 📋 프로젝트 소개

자바를 활용하여 쉐이크쉑 햄버거 키오스크 시스템을 개발한 프로젝트입니다. 단순한 메뉴 선택부터 시작해 객체지향 설계 원칙을 적용하고, 캡슐화와 같은 객체지향 프로그래밍의 핵심 개념을 적용해보았습니다.

이 프로젝트는 단계적으로 기능을 확장하며 자바의 다양한 기능과 객체지향 설계 원칙을 학습하기 위한 목적으로 진행되었습니다.

## 🛠️ 개발 과정 및 고민

### 첫 시작: 기본 키오스크 구현
처음에는 단순히 메뉴를 표시하고 사용자 입력을 처리하는 기본적인 키오스크 기능을 구현했습니다. 모든 코드가 하나의 클래스 파일에 있었고, 구조화되지 않았지만 기본 기능은 동작했습니다.

```java
// 처음 구현했던 단순한 방식
Scanner scanner = new Scanner(System.in);
System.out.println("[ SHAKESHACK MENU ]");
System.out.println("1. ShackBurger | W 6.9 | 토마토, 양상추, 쉑소스가 토핑된 치즈버거");
// ... 메뉴 출력 코드
```

### 객체지향 설계 적용
코드가 길어지고 복잡해지면서 유지보수의 어려움을 느꼈습니다. 이를 개선하기 위해 `MenuItem` 클래스를 만들어 메뉴 정보를 관리하게 했습니다.

```java
// MenuItem 클래스를 통해 메뉴 정보 캡슐화
public class MenuItem {
    private String name;
    private double price;
    private String description;
    
    // 생성자, getter, setter 등
}
```

### 구조 개선과 책임 분리
메뉴 표시와 입력 처리 등 모든 로직이 Main 클래스에 있는 것이 비효율적이라 생각했습니다. 키오스크 동작을 담당하는 `Kiosk` 클래스를 만들어 관심사를 분리했습니다.

```java
// Kiosk 클래스를 통해 키오스크 동작 로직 분리
public class Kiosk {
    private List<MenuItem> menuItems;
    
    public void start() {
        // 키오스크 실행 로직
    }
    
    // 다른 메서드들...
}
```

### 계층적 메뉴 구조 도입
실제 키오스크처럼 카테고리별 메뉴 구조가 필요하다고 생각했습니다. `Menu` 클래스를 추가해 '버거', '음료', '디저트' 등의 카테고리를 만들고, 각 카테고리 안에 메뉴 항목을 구성했습니다.

```java
// Menu 클래스를 통한 카테고리 구현
public class Menu {
    private String name;  // 카테고리 이름 (예: "Burgers")
    private List<MenuItem> menuItems;
    
    // 메서드들...
}
```

### 캡슐화 원칙 적용
프로그램이 커지면서 데이터 보호와 일관성 유지가 중요해졌습니다. 모든 클래스의 필드를 private으로 선언하고, getter/setter 메서드를 통해서만 접근하도록 캡슐화 원칙을 적용했습니다.

메뉴 이름을 일정한 길이로 맞추기 위한 formatName 메서드도 구현했는데, 이는 출력을 깔끔하게 하는 데 큰 도움이 되었습니다.

```java
private String formatName(String name) {
    int length = 16;
    if (name.length() >= length) {
        return name;
    }

    for (int i = name.length(); i < length; i++) {
        name += " ";
    }
    return name;
}
```

## 💡 주요 기능

### 메뉴 관리 시스템
- 버거, 음료, 디저트 등 다양한 카테고리의 메뉴 관리
- 각 메뉴 항목의 이름, 가격, 설명 정보 저장 및 출력
- 계층적 메뉴 구조를 통한 직관적인 탐색

### 사용자 인터페이스
- 메인 메뉴와 카테고리별 하위 메뉴 제공
- 메뉴 선택 및 뒤로가기 기능
- 출력 포맷팅을 통한 정돈된 UI

### 객체지향 설계
- 클래스 간 책임 분리로 코드 관리 용이
- 캡슐화를 통한 데이터 보호
- 확장성을 고려한 구조 설계

## 🚀 시연 예시

```
[ MAIN MENU ]
1. Burgers
2. Drinks
3. Desserts
0. 종료 | 종료
메뉴를 선택하세요: 1

[ BURGERS MENU ]
1. ShackBurger    | W 6.9 | 토마토, 양상추, 쉑소스가 토핑된 치즈버거
2. SmokeShack     | W 8.9 | 베이컨, 체리 페퍼에 쉑소스가 토핑된 치즈버거
3. Cheeseburger   | W 6.9 | 포테이토 번과 비프패티, 치즈가 토핑된 치즈버거
4. Hamburger      | W 5.4 | 비프패티를 기반으로 야채가 들어간 기본버거
0. 뒤로가기
메뉴를 선택하세요: 2

선택한 메뉴: SmokeShack | W 8.9 | 베이컨, 체리 페퍼에 쉑소스가 토핑된 치즈버거
---------------------------
```

## 🔧 문제 해결 과정

### 메뉴 출력 정렬 문제
메뉴 항목의 이름 길이가 다를 경우 출력이 잘 정렬되지 않는 문제가 있었습니다. 이를 해결하기 위해 formatName 메서드를 구현했습니다. 이 메서드는 이름이 지정된 길이보다 짧으면 공백을 추가해 일정한 길이가 되도록 했습니다.

### 사용자 입력 예외 처리
처음에는 사용자가 메뉴 번호가 아닌 다른 입력을 했을 때 프로그램이 충돌하는 문제가 있었습니다. 이를 해결하기 위해 입력값 검증 로직을 추가했습니다.

```java
if (choice >= 1 && choice <= menus.size()) {
    // 선택된 메뉴 처리
} else {
    System.out.println("메뉴의 숫자를 입력해주세요.");
}
```

## 📝 추가 예정 기능

향후 다음 기능들을 추가할 계획입니다:

1. **장바구니 기능**:
   - 메뉴 선택 시 장바구니에 추가
   - 장바구니 내역 확인 및 총 금액 계산

2. **주문 기능**:
   - 장바구니에서 주문하기
   - 주문 확인 및 결제 프로세스

3. **할인 시스템**:
   - Enum을 활용한 사용자 타입별 할인율 구현
   - 람다와 스트림을 통한 고급 데이터 처리
